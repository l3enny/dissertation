The global model code was written in Python (version 2.7) using the standard
libraries, NumPy (version 1.6), SciPy (version 0.11) \cite{Jones2001}, and
Matplotlib 1.3 \cite{Hunter2007}. The code will be included here for reference,
however the most up-to-date version will be maintained at
\url{https://github.com/l3enny/crammer}. Presently, the \texttt{conserve} branch
is the one that is in regular use, however its changes will eventually be merged
into the main branch. Below is a diagram of the directory structure used for the
global model code. Some additional files are present in the repository, but were
not used in producing the analysis presented here.

{
\dirtree{%
  .1 /. 
  .2 distributions.py. 
  .2 equilibrium. 
  .2 gases. 
  .3 \_\_init\_\_.py.
  .3 helium. 
  .4 \_\_init\_\_.py.
  .4 atomic.py.
  .4 constants.py.
  .4 optical.py.
  .4 states.py.
  .2 handler.py.
  .2 initcond.py.
  .2 matrixgen.py.
  .2 rates.py.
  .2 ratio.py.
  .2 script.py.
  .2 settings.
  .3 s1torr.py.
  .3 s4torr.py.
  .3 s8torr.py.
  .2 script.py.
  .2 solvers.py.
}
}

The global model is initialized by running the \texttt{script.py} file.
\begin{singlespace}
  \lstinputlisting{./code/crammer/script.py}
\end{singlespace}
As with the laser-absorption analysis code, this script mostly handles the logic
of the solutions and hands off the actual calculations to other libraries or
submodules. Aside from the importation of several submodules, the script
critically imports a settings file which determines much of how the solver
behaves. The settings file is intended to be much more straightforward to edit
in comparison to the solution script. An example of this is the settings file
for the 4.0 Torr conditions, \texttt{s4torr.py}.
\begin{singlespace}
  \lstinputlisting{./code/crammer/settings/s4torr.py}
\end{singlespace}
Because the main script imports all of the settings into its namespace, it is
important that the settings file define all of the variables listed in this
example. The settings file is generally well-commented, therefore little will be
said about the variables contained therein. The one notable exception is at the
beginning where two serialized objects (``pickles'') are loaded in to the
variables \texttt{km} and \texttt{coeffs}. As recorded in the comments,
\texttt{km} contains the function which generates the momentum transfer rate
coefficient. Similarly, \texttt{coeffs} contains the functions which generate
the electron-induced transition rate coefficients.

Both of these coefficient files are generated by a separate script, called
\texttt{rategen}. The function of this script will be described at the end of
this appendix. From an application standpoint, the \texttt{coeffs} function
accepts a float, and two integers as its inputs. The float is the electron
temperature in K, and the integers are unique identifiers of the excited atomic
state (in the form of $nSL$).

Finally, it should be noted that the settings file also imports a file called
\texttt{equilibrium.npy}. This file is generated by the settings file
\texttt{equilibrium.py} and contains the equilibrium values for the various
excited atomic states.

After the importation of the settings, the script also imports the states
information from the gas defined in the settings. It should be noted that the
\texttt{\_\_init\_\_.py} file in the gases directory contains a single line:
\texttt{\_\_all\_\_ = ['helium']}. This provides a hint to the Python runtime
about what submodules are included in the gases module. In this case, the gas is
helium, and the \texttt{states.py} file is recorded below.
\begin{singlespace}
  \lstinputlisting{./code/crammer/gases/helium/states.py}
\end{singlespace}
The states are contained in a single dictionary and referenced by their unique
integer indentifier. The energy of each state as well as its degeneracy is also
recorded here. Any commented state is automatically excluded from the
simulation.

After the states are imported by the script, an list is generated with their
indentifiers in order of energy. This is done because Python does not guarantee
the order of dictionaries. This order listing is later used for consistent
generation of the transition matrices. The transition matrices are produce by
the \texttt{matrixgen.py} submodule.
\begin{singlespace}
  \lstinputlisting{./code/crammer/matrixgen.py}
\end{singlespace}
This submodule contains all the function definitions necessary to generate the
various transition matrices. Conceptually, the row index is the same index as
the final state identifier in the \texttt{order} list. Likewise, the column
indicates the initial state index. The matrix generation functions automatically
track the losses and gains for each state and ensure conservation of particles.

After the transition matrices are generated, the \texttt{solvers.py} submodule
is used to generate the transition energies.
\begin{singlespace}
  \lstinputlisting{./code/crammer/solvers.py}
\end{singlespace}
This submodule does most of the calculations, though some of the functions (such
as the singular value decomposition) are wrappers for the SciPy equivalent. Also
in this submodule is a function which returns all the possible optical
transition wavelengths. Furthermore, two types of Runge-Kutta integrators are in
this submodule. The first is a simple fourth order method. The second implements
a fourth order method with a fifth order adaptive step size adjustment. The
latter of the two implements a generator pattern so that it could conceivably be
used without looping.

Returning to the main script, the differential equation describing the evolution
of the state density is set up, followed by the energy equation. Then, the
initial values are set up (based on the settings file), and the solution arrays
are initialized. This is followed by the solution loop which steps through the
evolution of the system and adjusts the rate coefficients as necessary. After
the end of the simulation period has been reached, the output files are opened
for writing, a process taken care of by \texttt{handler.py}.
\begin{singlespace}
  \lstinputlisting{./code/crammer/handler.py}
\end{singlespace}

As was mentioned earlier, the rate coefficients which are important to the use
of the global model are generated by a separate program and compiled into
serialized objects. The objects implement a \texttt{Rates} class which is
contained in \texttt{rates.py}.
\begin{singlespace}
  \lstinputlisting{./code/crammer/rates.py}
\end{singlespace}
The class acts as a data container for rate coefficients calculated at fixed
temperatures. It then implements a simple interpolating spline in order to
return appropriate rate coefficients as requested by the main script.

The \texttt{rategen} program can be accessed at the online repository,
\url{https://github.com/l3enny/rategen}. For the most part, it implements a
simple convolution routine around the transcribed cross sections and parses the
results into the above class. The contents of the \texttt{rategen} directory
include the listing below as well as several other files which are not necessary
for the analysis presented here.

{
\dirtree{%
  .1 /. 
  .2 settings.
  .3 combined.py.
  .3 pack1p0.py.
  .2 xsections.
  .3 \_\_init\_\_.py.
  .3 helium.
  .2 constants.py.
  .2 convolve.py. 
  .2 distributions.py. 
  .2 main.py.
  .3 rates.py.
}
}

The program begins with a call to \texttt{main.py}.
\begin{singlespace}
  \lstinputlisting{./code/rategen/main.py}
\end{singlespace}
This script begins with the necessary imports as well as the necssary imports,
most notably, the importation of the settings file. The settings file contains
the necessary information for the generation of the rate constants: temperatures
to use, type of distribution, comments, output name. Two examples follow, the
first, \texttt{combined.py}, was used to generate the electron-related rate
coefficients.
\begin{singlespace}
  \lstinputlisting{./code/rategen/settings/combined.py}
\end{singlespace}
In this case the cross sections and rates are imported from separate files
contained in the \texttt{xsections} directory. However, given the copyright on
these cross sections, this information is not reproduced here. The settings file
also imports the same \texttt{states.py} submodule as the \texttt{crammer}
script. Additionally, the settings import the distribution submodule,
\texttt{distributions.py}.
\begin{singlespace}
  \lstinputlisting{./code/rategen/distributions.py}
\end{singlespace}
This submodule includes a Maxwell-Boltzmann distribution, as well as a
two-factor distribution which is continuously variable between a Druyvesteyn
distribution and a Maxwell-Boltzmann.

After the settings are imported by the main script, it proceeds to assemble the
rate coefficients by convolving the selected distribution function with the
appropriate cross section. This is done via the \texttt{convolve.py} submodule.
\begin{singlespace}
  \lstinputlisting{./code/rategen/convolve.py}
\end{singlespace}
The convolve routine is a relatively simple numerical integration of the cross
section with That said, the maximum integration energy is hard-coded, therefore
the user should make the appropriate adjustments for reaction cross sections
and distribution functions with significant values past 100 eV. the distribution function. That said, the maximum integration
energy is hard-coded, therefore the user should make the appropriate adjustments
for reaction cross sections and distribution functions with significant values
past 100 eV.
